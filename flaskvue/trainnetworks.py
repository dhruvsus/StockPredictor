# -*- coding: utf-8 -*-
"""trainNetworks.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/dhruvsus/StockPredictor/blob/master/trainNetworks.ipynb
"""

#pip installs for google colab
"""!pip install yfinance
!pip install pandas
!pip install numpy
!pip install matplotlib
!pip install scikit-learn
!pip install torch
!pip install bs4
!pip install requests"""

#imports
import requests
import yfinance as yf
from bs4 import BeautifulSoup
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import torch.nn as nn
import torch
from torch.autograd import Variable
import dateutil
from sklearn.preprocessing import MinMaxScaler
from sklearn.model_selection import train_test_split

"""Pytorch configuration"""

#enable or diable GPU compute
if torch.cuda.is_available():
    device = torch.device('cuda')
    print(torch.cuda.get_device_name(device))
else:
    device = torch.device('cpu')

"""Network definition"""

class RNN(nn.Module):
    def __init__(self, i_size, h_size, n_layers, o_size, tickerName):
        super(RNN, self).__init__()
        self.tickerName=tickerName

        self.rnn = nn.LSTM(
            input_size=i_size,
            hidden_size=h_size,
            num_layers=n_layers,
        )
        self.out = nn.Linear(h_size, o_size)

    def forward(self, x, h_state):
        r_out, hidden_state = self.rnn(x, h_state)
        
        hidden_size = hidden_state[-1].size(-1)
        r_out = r_out.view(-1, hidden_size)
        outs = self.out(r_out)

        return outs, hidden_state

"""Get the tickers of the companies in the Stock and Poor's Top 500"""

def getTickersSP500():
  LIST_OF_COMPANIES_WIKI = 'https://en.wikipedia.org/wiki/List_of_S%26P_500_companies'
  website_url = requests.get(LIST_OF_COMPANIES_WIKI).text
  soup = BeautifulSoup(website_url, "html.parser")
  my_table = soup.find('table',{'class':'wikitable sortable', 'id': "constituents"})
  label_items = my_table.findAll('a', {'class': 'external text', 'rel': 'nofollow'})
  labels = []
  for label_item in label_items:
    label = label_item.get_text()
    if label == 'reports' or label == 'Aptiv Plc':
        continue
    labels.append(label)
  return labels

"""Create training and test dataset out of the the stock history"""

def createTrainTestDataset(tickerName):
  #error checking for old/invalid tickers
  #return 1 for invalid dimensions
  #since yfinance returns an empty df on error
  ticker = yf.Ticker(tickerName)
  data_set = ticker.history(period="max")
  data_set = data_set[data_set.index>dateutil.parser.parse("2009-06-01")]
  data_set = data_set.drop(['Dividends', 'Stock Splits', 'High', 'Low', 'Close','Volume'], axis = 1)
  train_set, test_set = train_test_split(data_set, test_size=0.2, train_size=0.8, shuffle=False)
  sc = MinMaxScaler(feature_range = (0, 1))
  train_fit = sc.fit(train_set)
  train_scaled = sc.transform(train_set)
  # Creating a data structure with 60 timesteps and 1 output
  x_train = []
  y_train = []
  for i in range(INPUT_SIZE, train_scaled.shape[0]):
    x_train.append(train_scaled[i-INPUT_SIZE:i, 0])
    y_train.append(train_scaled[i, 0])
  x_train, y_train = np.array(x_train), np.array(y_train)

  # Reshaping
  x_train = np.reshape(x_train, (x_train.shape[0], 1, x_train.shape[1]))
  return x_train, y_train, train_set, test_set, sc

"""Function definition to establish hyper-parameters and return network"""

# network hyper parameters
INPUT_SIZE = 60
HIDDEN_SIZE = 64
NUM_LAYERS = 1
OUTPUT_SIZE = 1
learning_rate = 0.001
num_epochs = 100

def createNetwork(tickerName):
  rnn = RNN(INPUT_SIZE, HIDDEN_SIZE, NUM_LAYERS, OUTPUT_SIZE, tickerName).to(device)
  criterion = nn.MSELoss()
  optimizer = torch.optim.Adam(rnn.parameters(), lr=learning_rate)
  hidden_state = None
  return rnn, optimizer, criterion, hidden_state

"""Train the neural network using the training data"""

def trainNetwork(network, optimizer, criterion, hidden_state):
  for epoch in range(num_epochs):
    inputs = Variable(torch.from_numpy(x_train).float()).to(device)
    labels = Variable(torch.from_numpy(y_train).float()).to(device)
    output, hidden_state = network(inputs, hidden_state)
    loss = criterion(output.view(-1), labels)
    optimizer.zero_grad()
    loss.backward(retain_graph=True)                     # back propagation
    optimizer.step()                                     # update the parameters
    torch.cuda.empty_cache()
    print('epoch {}, loss {}'.format(epoch,loss.item()))

def testNetwork(network, x_train, y_train, train_set, test_set, sc):
  real_stock_price = test_set.values
  total_set = pd.concat((train_set['Open'], test_set['Open']), axis = 0)
  inputs = total_set[len(total_set) - len(test_set) - INPUT_SIZE:].values
  inputs = inputs.reshape(-1,1)
  inputs = sc.transform(inputs)

  x_test = []
  for i in range(INPUT_SIZE, inputs.shape[0]):
      x_test.append(inputs[i-INPUT_SIZE:i, 0])
  x_test = np.array(x_test)
  x_test = np.reshape(x_test, (x_test.shape[0], 1, x_test.shape[1]))

  x_train_x_test = np.concatenate((x_train, x_test),axis=0)
  hidden_state = None
  test_inputs = Variable(torch.from_numpy(x_train_x_test).float()).cuda()
  predicted_stock_price, b = network(test_inputs, hidden_state)
  predicted_stock_price = np.reshape(predicted_stock_price.detach().cpu().numpy(), (test_inputs.shape[0], 1))
  predicted_stock_price = sc.inverse_transform(predicted_stock_price)

  real_stock_price_all = np.concatenate((train_set[INPUT_SIZE:], real_stock_price))
  print(real_stock_price_all.shape)
  print(predicted_stock_price.shape)
  # Visualising the results
  plt.figure(1, figsize=(12, 5))
  plt.plot(real_stock_price_all, color = 'red', label = 'Real')
  plt.plot(predicted_stock_price, color = 'blue', label = 'Pred')
  plt.title('Stock Price Prediction')
  plt.xlabel('Time')
  plt.ylabel('Stock Price')
  plt.legend()
  plt.show()

def predictStock():
    tickers = getTickersSP500()
    for tickerNumber, tickerName in enumerate(tickers):
      if tickerNumber<10:
        x_train, y_train, train_set, test_set, sc = createTrainTestDataset(tickerName)
        network, optimizer, criterion, hidden_state = createNetwork(tickerName)
        trainNetwork(network, optimizer, criterion, hidden_state)
        testNetwork(network, x_train, y_train, train_set, test_set, sc)
        # memory cleanup
        del network
        del optimizer
        del criterion
        del hidden_state
        torch.cuda.empty_cache()

